# 13장 동시성

> 객체는 처리의 추상화다. 스레드는 일정의 추상화다.
- 제임스 O. 코플리엔
> 

### 동시성이 필요한 이유?

동시성은 결합을 없애는 전략이다
즉, 무엇과 언제를 분리하는 전략이다
무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다
*멀티 쓰레드, singleton을 사용하면 동시성 문제가 사라진다*

**미신과 오해**

동시성의 미신과 오해

- 동시성은 항상 성능을 높여준다
    - 동시성은 때로 성능을 높여준다
- 동시성을 구현해도 설계는 변하지 않는다
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다

**동시성과 관련된 타당한 생각**

- 동시성은 다소 부하를 유발
- 동시성은 복잡
- 일반적으로 동시성 버그는 재현하지 어렵다
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다

**난관**

*이 부분은 스프링 핵심 원리 - 고급편에 나오는 쓰레드의 문제점 예시와 비슷하다*

[ThreadLocal](https://www.notion.so/ThreadLocal-b2525128318b49a295e788346d192bf9) 

**동시성 방어 원칙**

- 단일 책임 원칙 (Single Responsibility Principle, SRP)
    - 권장사항 : 동시성 코드는 다른 코드와 분리하라
- 따름 정리
    - 자료 범위를 제한하라
        - 임계 영역을 보호하여라
        - 권장사항 : 자료를 캡슐화하라 공유 자료를 최대한 줄여라
        - *static 주의*
    - 자료 사본을 사용하라
        - 각 쓰레드가 각 스레드가 객체를 복사해 사용한 후 스레드가 해당 사본에서 결과를 가져오는 방법이 있다
        - 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다
    - 스레드는 가능한 독립적으로 구현하라
        - 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라

**라이브러리를 이해하라**

언어가 제공하는 클래스를 검토하라

*이건 세대 간 차이가 존재할 것 같아 안넣었다 궁금하면 구글링 해라*

**실행 모델을 이해하라**

- 생산자 - 소비자
    - 하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다
    - 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다
    - 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정적이다
    - 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다
- 읽기 - 쓰기
    - 읽기 쓰레드가 없을 때 까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이 있다
    - 읽기 스레드가 계속 이어진다면 쓰기 쓰레드는 기아 상태에 빠진다
    - 양쪽 균형을 잡으면서 동시 갱신 문제를 피하는 해법이 필요
- 식사하는 철학자들
    - 각 쓰레드 왼쪽에는 자원이 놓였다 식탁 가운데는 커다란 스파게티 한 접시가 놓였다 쓰레드들은 배가 고프지 않으면 생각하며 시간을 보낸다 배가 고프면 양손에 자원을 집어들고 스파게티를 먹는다 양손에 자원을 쥐지 아낳으면 먹지 못한다 왼쪽 쓰레드나 오른쪽 쓰레드가 자원을 사용하는 중이라면 그쪽 쓰레드가 먹고 나서 자원을 내려놓을 때 까지 기다려야 한다 스파게티를 먹고 나면 자원을 내려놓고 배가 고플 때까지 다시 생각에 잠긴다

권장사항 : 데드락, 라이브락, 처리율 저하, 효율성 저하의 해법을 이해하라

**동기화하는 메서드 사이에 존재하는 의존성을 이해하라**

권장사항 : 공유 객체 하나에는 메서드 하나만 사용하라

*JDK 동적 프록시* [동적 프록시 기술](https://www.notion.so/dbcb64696472468f89740c82b7c20db6) 

공유 객체 하나에 여러 메서드가 필요한 상황에는 다음 세 가지 방법을 고려한다

1. 클라이언트에서 잠금 - 클라리언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠그고 마지막 메서드를 호출할 때 까지 잠금을 유지한다
2. 서버에서 잠금 - 서버를 잠그고 무든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현한다
3. 연결 서버 - 잠금을 수행하는 중간 단계를 생성한다

**동기화하는 부분을 작게 만들어라**

임계 영역을 보호하여야 한다

권장 사항 : 동기화하는 부분을 최대한 작게 만들어라

**올바른 종료 코드는 구현하기 어렵다**

부모 스레드가 자식 스레드를 여러 개 만든 후 모두가 끝나기를 기다렸다 자우너을 해제하고 종료하는 시스템이 있다
만약 자식 스레드 중 하나가 데드락에 걸렸다면? 부모 스레드는 영원히 기다리고, 시스템은 영원히 종료하지 못한다

권장 사항 : 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라 생각보다 오래 걸린다 생각보다 어려우므로 이미 나온 알고리즘을 검토하라
