# 13장 동시성

> 객체는 처리의 추상화다. 스레드는 일정의 추상화다.
- 제임스 O. 코플리엔
> 

### 동시성이 필요한 이유?

동시성은 결합을 없애는 전략이다
즉, 무엇과 언제를 분리하는 전략이다
무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다
*멀티 쓰레드, singleton을 사용하면 동시성 문제가 사라진다*

**미신과 오해**

동시성의 미신과 오해

- 동시성은 항상 성능을 높여준다
    - 동시성은 때로 성능을 높여준다
- 동시성을 구현해도 설계는 변하지 않는다
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다

**동시성과 관련된 타당한 생각**

- 동시성은 다소 부하를 유발
- 동시성은 복잡
- 일반적으로 동시성 버그는 재현하지 어렵다
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다

**난관**

*이 부분은 스프링 핵심 원리 - 고급편에 나오는 쓰레드의 문제점 예시와 비슷하다*

[ThreadLocal](https://www.notion.so/ThreadLocal-b2525128318b49a295e788346d192bf9) 

**동시성 방어 원칙**

- 단일 책임 원칙 (Single Responsibility Principle, SRP)
    - 권장사항 : 동시성 코드는 다른 코드와 분리하라
- 따름 정리
    - 자료 범위를 제한하라
        - 임계 영역을 보호하여라
        - 권장사항 : 자료를 캡슐화하라 공유 자료를 최대한 줄여라
        - *static 주의*
    - 자료 사본을 사용하라
        - 각 쓰레드가 각 스레드가 객체를 복사해 사용한 후 스레드가 해당 사본에서 결과를 가져오는 방법이 있다
        - 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다
    - 스레드는 가능한 독립적으로 구현하라
        - 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라

**라이브러리를 이해하라**

언어가 제공하는 클래스를 검토하라

*이건 세대 간 차이가 존재할 것 같아 안넣었다 궁금하면 구글링 해라*

**실행 모델을 이해하라**

- 생산자 - 소비자
    - 하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다
    - 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다
    - 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정적이다
    - 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다
- 읽기 - 쓰기
    - 읽기 쓰레드가 없을 때 까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이 있다
    - 읽기 스레드가 계속 이어진다면 쓰기 쓰레드는 기아 상태에 빠진다
    - 양쪽 균형을 잡으면서 동시 갱신 문제를 피하는 해법이 필요
-
