# 13장 동시성

> 객체는 처리의 추상화다. 스레드는 일정의 추상화다.
- 제임스 O. 코플리엔
> 

### 동시성이 필요한 이유?

동시성은 결합을 없애는 전략이다
즉, 무엇과 언제를 분리하는 전략이다
무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다
*멀티 쓰레드, singleton을 사용하면 동시성 문제가 사라진다*

**미신과 오해**

동시성의 미신과 오해

- 동시성은 항상 성능을 높여준다
    - 동시성은 때로 성능을 높여준다
- 동시성을 구현해도 설계는 변하지 않는다
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다

**동시성과 관련된 타당한 생각**

- 동시성은 다소 부하를 유발
- 동시성은 복잡
- 일반적으로 동시성 버그는 재현하지 어렵다
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다

**난관**

*이 부분은 스프링 핵심 원리 - 고급편에 나오는 쓰레드의 문제점 예시와 비슷하다*

[ThreadLocal](https://www.notion.so/ThreadLocal-b2525128318b49a295e788346d192bf9) 

**동시성 방어 원칙**

- 단일 책임 원칙 (Single Responsibility Principle, SRP)
    - 권장사항 : 동시성 코드는 다른 코드와 분리하라
- 따름 정리
    - 자료 범위를 제한하라
        - 임계 영역을 보호하여라
        - 권장사항 : 자료를 캡슐화하라 공유 자료를 최대한 줄여라
        - *static 주의*
    - 자료 사본을 사용하라
        - 각 쓰레드가 각 스레드가 객체를 복사해 사용한 후 스레드가 해당 사본에서 결과를 가져오는 방법이 있다
        - 가비지 컬렉션에 드는 부하를 상쇄할 가능성이 크다
    - 스레드는 가능한 독립적으로 구현하라
        - 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라

**라이브러리를 이해하라**

언어가 제공하는 클래스를 검토하라

*이건 세대 간 차이가 존재할 것 같아 안넣었다 궁금하면 구글링 해라*

**실행 모델을 이해하라**

- 생산자 - 소비자
    - 하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다
    - 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다
    - 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정적이다
    - 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다
- 읽기 - 쓰기
    - 읽기 쓰레드가 없을 때 까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이 있다
    - 읽기 스레드가 계속 이어진다면 쓰기 쓰레드는 기아 상태에 빠진다
    - 양쪽 균형을 잡으면서 동시 갱신 문제를 피하는 해법이 필요
- 식사하는 철학자들
    - 각 쓰레드 왼쪽에는 자원이 놓였다 식탁 가운데는 커다란 스파게티 한 접시가 놓였다 쓰레드들은 배가 고프지 않으면 생각하며 시간을 보낸다 배가 고프면 양손에 자원을 집어들고 스파게티를 먹는다 양손에 자원을 쥐지 아낳으면 먹지 못한다 왼쪽 쓰레드나 오른쪽 쓰레드가 자원을 사용하는 중이라면 그쪽 쓰레드가 먹고 나서 자원을 내려놓을 때 까지 기다려야 한다 스파게티를 먹고 나면 자원을 내려놓고 배가 고플 때까지 다시 생각에 잠긴다

권장사항 : 데드락, 라이브락, 처리율 저하, 효율성 저하의 해법을 이해하라

**동기화하는 메서드 사이에 존재하는 의존성을 이해하라**

권장사항 : 공유 객체 하나에는 메서드 하나만 사용하라

*JDK 동적 프록시* [동적 프록시 기술](https://www.notion.so/dbcb64696472468f89740c82b7c20db6) 

공유 객체 하나에 여러 메서드가 필요한 상황에는 다음 세 가지 방법을 고려한다

1. 클라이언트에서 잠금 - 클라리언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠그고 마지막 메서드를 호출할 때 까지 잠금을 유지한다
2. 서버에서 잠금 - 서버를 잠그고 무든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현한다
3. 연결 서버 - 잠금을 수행하는 중간 단계를 생성한다

**동기화하는 부분을 작게 만들어라**

임계 영역을 보호하여야 한다

권장 사항 : 동기화하는 부분을 최대한 작게 만들어라

**올바른 종료 코드는 구현하기 어렵다**

부모 스레드가 자식 스레드를 여러 개 만든 후 모두가 끝나기를 기다렸다 자우너을 해제하고 종료하는 시스템이 있다
만약 자식 스레드 중 하나가 데드락에 걸렸다면? 부모 스레드는 영원히 기다리고, 시스템은 영원히 종료하지 못한다

권장 사항 : 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라 생각보다 오래 걸린다 생각보다 어려우므로 이미 나온 알고리즘을 검토하라

**스레드 코드 테스트하기**

같은 코드와 같은 자원을 사용하는 스레드가 둘 이상으로 늘어나면 상황은 급격하게 복잡해진다

권장 사항 : 문제를 노출하는 테스트 케이스를 작성하라 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라

- 말이 안되는 실패는 잠정적인 스레드 문제로 취급
    - ‘일회성’ 문제를 계속 무시한다면 잘못된 코드 위에 코드가 계속 쌓인다
    - 권장 사항 : 시스템 실패를 ‘일회성’이라 치부하지 마라
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌아가게 만들어라
    - 스레드 환경 밖에서 테스트가 가능
    - 권장 사항 : 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지마라 먼저 스레드 환경 밖에서 코드를 올바로 돌려라
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 구현
    - 실행 중 스레드 수를 바꿔보기
    - 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다
    - 다양한 속도로 돌려보기
    - 반복 테스트 가능하게 테스트 케이스 작성
- 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성
    - *thread pool이 생각났음 [웹 애플리케이션의 이해](https://www.notion.so/d20f372dbfe749f7b3f3cde38307693f)*
    - 스스로 스레드 개수를 조율하는 코드 고민
- 프로세서 수 보다 많은 스레드 돌리기
    - 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다
- 다른 플랫폼에서 돌리기
    - 권장 사항 : 처음부터 그리고 자주 사용하는 모든 목표 플랫폼에서 코드를 돌려라
- 코드에 보조 코드를 넣어 돌리기 (강제로 실패를 일으키게 해보기)
    - 직접 구현하기
        - *Thread 공부 필요하다고 느낌… 테트리스 한 번 만들어볼까*
        - 배포 환경이 아니라 테스트 환경에서 보조 코드를 실행할 방법이 필요
        - 실행할 때마다 설정을 바꿔줄 방법 필요
        - 스레드를 전혀 모르는 POJO와 스레드를 제어하는 클래스로 프로그램을
    - 자동화
        - 코드를 흔드는 이유는 스레드를 매번 다른 순서로 실행하기 위함
        - 권장 사항 : 흔들기 기법을 사용해 오류를 찾아내라

**결론**

다중 스레드 코드는 올바르게 구현하기 어렵다

1. SRP 준수
    1. 스레드를 아는 코드와 스레드를 모르는 코드를 분리
2. 동시성 오류를 일으키는 잠정적인 원인 이해
3. 사용하는 라이브러리와 기본 알고리즘 이해
4. 보호할 코드 영역을 찾아내는 방법, 특정 코드 영역을 잠그는 방법 이해
    1. 공유하는 객체수와 범위 줄이기
    2. 클라이언트에게 공유 상태를 관리하는 책임 떠넘기지 않기
    3. 필요하다면 객체 설계 변경해 클라이언트에게 편의 제공
5. 초반에 드러나지 않는 문제는 일회성으로 치부하면 안된다
    1. 스레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트
6. 시간을 들여 보조 코드를 추가
